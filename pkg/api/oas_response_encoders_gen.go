// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/uri"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
)

func encodeWaInstanceIdInstanceAddGroupParticipantApiTokenInstancePostResponse(response WaInstanceIdInstanceAddGroupParticipantApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceAddGroupParticipantApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceAddGroupParticipantApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceCheckAccountApiTokenInstancePostResponse(response WaInstanceIdInstanceCheckAccountApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceCheckAccountApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceCheckAccountApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceClearMessagesQueueApiTokenInstanceGetResponse(response *WaInstanceIdInstanceClearMessagesQueueApiTokenInstanceGetOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Connection" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Connection",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Connection.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Connection header")
			}
		}
		// Encode "Content-Length" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Content-Length",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ContentLength.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Content-Length header")
			}
		}
		// Encode "Date" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Date",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Date.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Date header")
			}
		}
		// Encode "Server" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Server",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Server.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Server header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))

	e := new(jx.Encoder)
	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}

	return nil
}

func encodeWaInstanceIdInstanceClearWebhooksQueueApiTokenInstanceDeleteResponse(response *WaInstanceIdInstanceClearWebhooksQueueApiTokenInstanceDeleteOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Connection" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Connection",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Connection.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Connection header")
			}
		}
		// Encode "Content-Length" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Content-Length",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ContentLength.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Content-Length header")
			}
		}
		// Encode "Date" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Date",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Date.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Date header")
			}
		}
		// Encode "Server" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Server",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Server.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Server header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))

	e := new(jx.Encoder)
	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}

	return nil
}

func encodeWaInstanceIdInstanceCreateGroupApiTokenInstancePostResponse(response WaInstanceIdInstanceCreateGroupApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceCreateGroupApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceCreateGroupApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceDeleteMessageApiTokenInstancePostResponse(response WaInstanceIdInstanceDeleteMessageApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceDeleteMessageApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "ETag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "ETag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ETag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode ETag header")
				}
			}
			// Encode "Expect-CT" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-CT",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCT.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-CT header")
				}
			}
			// Encode "Keep-Alive" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Keep-Alive",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.KeepAlive.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Keep-Alive header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-DNS-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-DNS-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-DNS-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-XSS-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-XSS-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-XSS-Protection header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceDeleteMessageApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "ETag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "ETag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ETag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode ETag header")
				}
			}
			// Encode "Expect-CT" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-CT",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCT.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-CT header")
				}
			}
			// Encode "Keep-Alive" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Keep-Alive",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.KeepAlive.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Keep-Alive header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-DNS-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-DNS-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-DNS-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-XSS-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-XSS-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-XSS-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceDeleteNotificationApiTokenInstanceReceiptIdDeleteResponse(response *WaInstanceIdInstanceDeleteNotificationApiTokenInstanceReceiptIdDeleteOK, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))

	e := new(jx.Encoder)
	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}

	return nil
}

func encodeWaInstanceIdInstanceDownloadFileApiTokenInstancePostResponse(response WaInstanceIdInstanceDownloadFileApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceDownloadFileApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Request-Id" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Request-Id",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRequestID.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Request-Id header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceDownloadFileApiTokenInstancePostBadRequest:
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceEditMessageApiTokenInstancePostResponse(response WaInstanceIdInstanceEditMessageApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceEditMessageApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "ETag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "ETag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ETag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode ETag header")
				}
			}
			// Encode "Expect-CT" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-CT",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCT.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-CT header")
				}
			}
			// Encode "Keep-Alive" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Keep-Alive",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.KeepAlive.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Keep-Alive header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-DNS-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-DNS-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-DNS-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-XSS-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-XSS-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-XSS-Protection header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceEditMessageApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "ETag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "ETag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ETag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode ETag header")
				}
			}
			// Encode "Expect-CT" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-CT",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCT.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-CT header")
				}
			}
			// Encode "Keep-Alive" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Keep-Alive",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.KeepAlive.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Keep-Alive header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-DNS-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-DNS-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-DNS-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-XSS-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-XSS-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-XSS-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceGetAccountSettingsApiTokenInstanceGetResponse(response *WaInstanceIdInstanceGetAccountSettingsApiTokenInstanceGetOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Access-Control-Allow-Headers" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Access-Control-Allow-Headers",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.AccessControlAllowHeaders.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
			}
		}
		// Encode "Access-Control-Allow-Methods" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Access-Control-Allow-Methods",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.AccessControlAllowMethods.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
			}
		}
		// Encode "Access-Control-Allow-Origin" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Access-Control-Allow-Origin",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.AccessControlAllowOrigin.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
			}
		}
		// Encode "Connection" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Connection",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Connection.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Connection header")
			}
		}
		// Encode "Content-Length" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Content-Length",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ContentLength.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Content-Length header")
			}
		}
		// Encode "Content-Security-Policy" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Content-Security-Policy",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ContentSecurityPolicy.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Content-Security-Policy header")
			}
		}
		// Encode "Date" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Date",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Date.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Date header")
			}
		}
		// Encode "ETag" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "ETag",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ETag.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode ETag header")
			}
		}
		// Encode "Expect-CT" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Expect-CT",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ExpectCT.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Expect-CT header")
			}
		}
		// Encode "Referrer-Policy" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Referrer-Policy",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ReferrerPolicy.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Referrer-Policy header")
			}
		}
		// Encode "Server" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Server",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Server.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Server header")
			}
		}
		// Encode "Strict-Transport-Security" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Strict-Transport-Security",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.StrictTransportSecurity.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Strict-Transport-Security header")
			}
		}
		// Encode "Vary" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Vary",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Vary.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Vary header")
			}
		}
		// Encode "X-Content-Type-Options" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "X-Content-Type-Options",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.XContentTypeOptions.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode X-Content-Type-Options header")
			}
		}
		// Encode "X-DNS-Prefetch-Control" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "X-DNS-Prefetch-Control",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.XDNSPrefetchControl.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode X-DNS-Prefetch-Control header")
			}
		}
		// Encode "X-Download-Options" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "X-Download-Options",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.XDownloadOptions.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode X-Download-Options header")
			}
		}
		// Encode "X-Frame-Options" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "X-Frame-Options",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.XFrameOptions.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode X-Frame-Options header")
			}
		}
		// Encode "X-Permitted-Cross-Domain-Policies" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "X-Permitted-Cross-Domain-Policies",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
			}
		}
		// Encode "X-RateLimit-Remaining" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "X-RateLimit-Remaining",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.XRateLimitRemaining.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode X-RateLimit-Remaining header")
			}
		}
		// Encode "X-RateLimit-Replenish-Rate" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "X-RateLimit-Replenish-Rate",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.XRateLimitReplenishRate.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
			}
		}
		// Encode "X-XSS-Protection" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "X-XSS-Protection",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.XXSSProtection.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode X-XSS-Protection header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))

	e := new(jx.Encoder)
	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}

	return nil
}

func encodeWaInstanceIdInstanceGetAvatarApiTokenInstancePostResponse(response WaInstanceIdInstanceGetAvatarApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceGetAvatarApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceGetAvatarApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceGetChatHistoryApiTokenInstancePostResponse(response WaInstanceIdInstanceGetChatHistoryApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceGetChatHistoryApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		e.ArrStart()
		for _, elem := range response.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceGetChatHistoryApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceGetChatsApiTokenInstanceGetResponse(response *WaInstanceIdInstanceGetChatsApiTokenInstanceGetOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Connection" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Connection",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Connection.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Connection header")
			}
		}
		// Encode "Content-Length" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Content-Length",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ContentLength.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Content-Length header")
			}
		}
		// Encode "Date" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Date",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Date.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Date header")
			}
		}
		// Encode "Strict-Transport-Security" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Strict-Transport-Security",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.StrictTransportSecurity.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Strict-Transport-Security header")
			}
		}
		// Encode "Vary" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Vary",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Vary.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Vary header")
			}
		}
		// Encode "X-RateLimit-Remaining" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "X-RateLimit-Remaining",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.XRateLimitRemaining.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode X-RateLimit-Remaining header")
			}
		}
		// Encode "X-RateLimit-Replenish-Rate" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "X-RateLimit-Replenish-Rate",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.XRateLimitReplenishRate.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))

	e := new(jx.Encoder)
	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}

	return nil
}

func encodeWaInstanceIdInstanceGetContactInfoApiTokenInstancePostResponse(response WaInstanceIdInstanceGetContactInfoApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceGetContactInfoApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceGetContactInfoApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceGetContactsApiTokenInstanceGetResponse(response *WaInstanceIdInstanceGetContactsApiTokenInstanceGetOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Connection" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Connection",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Connection.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Connection header")
			}
		}
		// Encode "Content-Length" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Content-Length",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ContentLength.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Content-Length header")
			}
		}
		// Encode "Date" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Date",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Date.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Date header")
			}
		}
		// Encode "Server" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Server",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Server.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Server header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))

	e := new(jx.Encoder)
	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}

	return nil
}

func encodeWaInstanceIdInstanceGetGroupDataApiTokenInstancePostResponse(response WaInstanceIdInstanceGetGroupDataApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceGetGroupDataApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceGetGroupDataApiTokenInstancePostBadRequest:
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceGetMessageApiTokenInstancePostResponse(response WaInstanceIdInstanceGetMessageApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceGetMessageApiTokenInstancePostOK:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceGetMessageApiTokenInstancePostBadRequest:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceGetMessagesCountApiTokenInstanceGetResponse(response *WaInstanceIdInstanceGetMessagesCountApiTokenInstanceGetOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Access-Control-Allow-Headers" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Access-Control-Allow-Headers",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.AccessControlAllowHeaders.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
			}
		}
		// Encode "Access-Control-Allow-Methods" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Access-Control-Allow-Methods",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.AccessControlAllowMethods.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
			}
		}
		// Encode "Access-Control-Allow-Origin" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Access-Control-Allow-Origin",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.AccessControlAllowOrigin.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
			}
		}
		// Encode "Connection" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Connection",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Connection.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Connection header")
			}
		}
		// Encode "Content-Length" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Content-Length",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ContentLength.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Content-Length header")
			}
		}
		// Encode "Content-Security-Policy" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Content-Security-Policy",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ContentSecurityPolicy.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Content-Security-Policy header")
			}
		}
		// Encode "Date" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Date",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Date.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Date header")
			}
		}
		// Encode "ETag" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "ETag",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ETag.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode ETag header")
			}
		}
		// Encode "Expect-CT" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Expect-CT",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ExpectCT.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Expect-CT header")
			}
		}
		// Encode "Referrer-Policy" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Referrer-Policy",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ReferrerPolicy.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Referrer-Policy header")
			}
		}
		// Encode "Strict-Transport-Security" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Strict-Transport-Security",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.StrictTransportSecurity.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Strict-Transport-Security header")
			}
		}
		// Encode "Vary" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Vary",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Vary.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Vary header")
			}
		}
		// Encode "X-Content-Type-Options" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "X-Content-Type-Options",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.XContentTypeOptions.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode X-Content-Type-Options header")
			}
		}
		// Encode "X-DNS-Prefetch-Control" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "X-DNS-Prefetch-Control",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.XDNSPrefetchControl.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode X-DNS-Prefetch-Control header")
			}
		}
		// Encode "X-Download-Options" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "X-Download-Options",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.XDownloadOptions.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode X-Download-Options header")
			}
		}
		// Encode "X-Frame-Options" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "X-Frame-Options",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.XFrameOptions.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode X-Frame-Options header")
			}
		}
		// Encode "X-Permitted-Cross-Domain-Policies" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "X-Permitted-Cross-Domain-Policies",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
			}
		}
		// Encode "X-XSS-Protection" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "X-XSS-Protection",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.XXSSProtection.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode X-XSS-Protection header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))

	e := new(jx.Encoder)
	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}

	return nil
}

func encodeWaInstanceIdInstanceGetSettingsApiTokenInstanceGetResponse(response *WaInstanceIdInstanceGetSettingsApiTokenInstanceGetOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Connection" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Connection",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Connection.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Connection header")
			}
		}
		// Encode "Content-Length" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Content-Length",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ContentLength.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Content-Length header")
			}
		}
		// Encode "Date" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Date",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Date.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Date header")
			}
		}
		// Encode "Server" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Server",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Server.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Server header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))

	e := new(jx.Encoder)
	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}

	return nil
}

func encodeWaInstanceIdInstanceGetStateInstanceApiTokenInstanceGetResponse(response *WaInstanceIdInstanceGetStateInstanceApiTokenInstanceGetOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Connection" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Connection",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Connection.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Connection header")
			}
		}
		// Encode "Content-Length" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Content-Length",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ContentLength.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Content-Length header")
			}
		}
		// Encode "Date" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Date",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Date.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Date header")
			}
		}
		// Encode "Server" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Server",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Server.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Server header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))

	e := new(jx.Encoder)
	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}

	return nil
}

func encodeWaInstanceIdInstanceGetWebhooksCountApiTokenInstanceGetResponse(response *WaInstanceIdInstanceGetWebhooksCountApiTokenInstanceGetOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Connection" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Connection",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Connection.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Connection header")
			}
		}
		// Encode "Content-Length" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Content-Length",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ContentLength.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Content-Length header")
			}
		}
		// Encode "Date" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Date",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Date.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Date header")
			}
		}
		// Encode "Server" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Server",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Server.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Server header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))

	e := new(jx.Encoder)
	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}

	return nil
}

func encodeWaInstanceIdInstanceLastIncomingMessagesApiTokenInstanceGetResponse(response *WaInstanceIdInstanceLastIncomingMessagesApiTokenInstanceGetOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Connection" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Connection",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Connection.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Connection header")
			}
		}
		// Encode "Content-Length" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Content-Length",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ContentLength.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Content-Length header")
			}
		}
		// Encode "Date" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Date",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Date.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Date header")
			}
		}
		// Encode "Server" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Server",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Server.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Server header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))

	e := new(jx.Encoder)
	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}

	return nil
}

func encodeWaInstanceIdInstanceLastOutgoingMessagesApiTokenInstanceGetResponse(response *WaInstanceIdInstanceLastOutgoingMessagesApiTokenInstanceGetOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Connection" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Connection",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Connection.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Connection header")
			}
		}
		// Encode "Content-Length" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Content-Length",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ContentLength.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Content-Length header")
			}
		}
		// Encode "Date" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Date",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Date.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Date header")
			}
		}
		// Encode "Server" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Server",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Server.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Server header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))

	e := new(jx.Encoder)
	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}

	return nil
}

func encodeWaInstanceIdInstanceLeaveGroupApiTokenInstancePostResponse(response WaInstanceIdInstanceLeaveGroupApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceLeaveGroupApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceLeaveGroupApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceLogoutApiTokenInstanceGetResponse(response *WaInstanceIdInstanceLogoutApiTokenInstanceGetOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Connection" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Connection",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Connection.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Connection header")
			}
		}
		// Encode "Content-Length" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Content-Length",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ContentLength.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Content-Length header")
			}
		}
		// Encode "Date" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Date",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Date.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Date header")
			}
		}
		// Encode "Server" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Server",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Server.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Server header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))

	e := new(jx.Encoder)
	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}

	return nil
}

func encodeWaInstanceIdInstanceQrApiTokenInstanceGetResponse(response *WaInstanceIdInstanceQrApiTokenInstanceGetDefStatusCode, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	code := response.StatusCode
	if code == 0 {
		// Set default status code.
		code = http.StatusOK
	}
	w.WriteHeader(code)
	if st := http.StatusText(code); code >= http.StatusBadRequest {
		span.SetStatus(codes.Error, st)
	} else {
		span.SetStatus(codes.Ok, st)
	}

	e := new(jx.Encoder)
	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}

	if code >= http.StatusInternalServerError {
		return errors.Wrapf(ht.ErrInternalServerErrorResponse, "code: %d, message: %s", code, http.StatusText(code))
	}
	return nil
}

func encodeWaInstanceIdInstanceReadChatApiTokenInstancePostResponse(response WaInstanceIdInstanceReadChatApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceReadChatApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceReadChatApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceRebootApiTokenInstanceGetResponse(response *WaInstanceIdInstanceRebootApiTokenInstanceGetOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Connection" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Connection",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Connection.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Connection header")
			}
		}
		// Encode "Content-Length" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Content-Length",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ContentLength.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Content-Length header")
			}
		}
		// Encode "Date" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Date",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Date.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Date header")
			}
		}
		// Encode "Server" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Server",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Server.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Server header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))

	e := new(jx.Encoder)
	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}

	return nil
}

func encodeWaInstanceIdInstanceReceiveNotificationApiTokenInstanceGetResponse(response *WaInstanceIdInstanceReceiveNotificationApiTokenInstanceGetOK, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))

	e := new(jx.Encoder)
	response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}

	return nil
}

func encodeWaInstanceIdInstanceRemoveAdminApiTokenInstancePostResponse(response WaInstanceIdInstanceRemoveAdminApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceRemoveAdminApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceRemoveAdminApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePostResponse(response WaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceSendContactApiTokenInstancePostResponse(response WaInstanceIdInstanceSendContactApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceSendContactApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceSendContactApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceSendFileByUploadApiTokenInstancePostResponse(response WaInstanceIdInstanceSendFileByUploadApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceSendFileByUploadApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceSendFileByUploadApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceSendFileByUrlApiTokenInstancePostResponse(response WaInstanceIdInstanceSendFileByUrlApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceSendFileByUrlApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceSendFileByUrlApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceSendLocationApiTokenInstancePostResponse(response WaInstanceIdInstanceSendLocationApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceSendLocationApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceSendLocationApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceSendMessageApiTokenInstancePostResponse(response WaInstanceIdInstanceSendMessageApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceSendMessageApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceSendMessageApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceSendTypingApiTokenInstancePostResponse(response WaInstanceIdInstanceSendTypingApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceSendTypingApiTokenInstancePostOK:
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		return nil

	case *WaInstanceIdInstanceSendTypingApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceSetGroupAdminApiTokenInstancePostResponse(response WaInstanceIdInstanceSetGroupAdminApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceSetGroupAdminApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceSetGroupAdminApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceSetGroupPictureApiTokenInstancePostResponse(response WaInstanceIdInstanceSetGroupPictureApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceSetGroupPictureApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceSetGroupPictureApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		e.Str(response.Response)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceSetProfilePictureApiTokenInstancePostResponse(response WaInstanceIdInstanceSetProfilePictureApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceSetProfilePictureApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceSetProfilePictureApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceSetSettingsApiTokenInstancePostResponse(response *WaInstanceIdInstanceSetSettingsApiTokenInstancePostOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Connection" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Connection",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Connection.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Connection header")
			}
		}
		// Encode "Content-Length" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Content-Length",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ContentLength.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Content-Length header")
			}
		}
		// Encode "Date" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Date",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Date.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Date header")
			}
		}
		// Encode "Server" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Server",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Server.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Server header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))

	e := new(jx.Encoder)
	response.Response.Encode(e)
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}

	return nil
}

func encodeWaInstanceIdInstanceShowMessagesQueueApiTokenInstanceGetResponse(response *WaInstanceIdInstanceShowMessagesQueueApiTokenInstanceGetOKHeaders, w http.ResponseWriter, span trace.Span) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	// Encoding response headers.
	{
		h := uri.NewHeaderEncoder(w.Header())
		// Encode "Connection" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Connection",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Connection.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Connection header")
			}
		}
		// Encode "Content-Length" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Content-Length",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.ContentLength.Get(); ok {
					return e.EncodeValue(conv.IntToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Content-Length header")
			}
		}
		// Encode "Date" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Date",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Date.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Date header")
			}
		}
		// Encode "Server" header.
		{
			cfg := uri.HeaderParameterEncodingConfig{
				Name:    "Server",
				Explode: false,
			}
			if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
				if val, ok := response.Server.Get(); ok {
					return e.EncodeValue(conv.StringToString(val))
				}
				return nil
			}); err != nil {
				return errors.Wrap(err, "encode Server header")
			}
		}
	}
	w.WriteHeader(200)
	span.SetStatus(codes.Ok, http.StatusText(200))

	e := new(jx.Encoder)
	e.ArrStart()
	for _, elem := range response.Response {
		elem.Encode(e)
	}
	e.ArrEnd()
	if _, err := e.WriteTo(w); err != nil {
		return errors.Wrap(err, "write")
	}

	return nil
}

func encodeWaInstanceIdInstanceUpdateGroupNameApiTokenInstancePostResponse(response WaInstanceIdInstanceUpdateGroupNameApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceUpdateGroupNameApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceUpdateGroupNameApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePostResponse(response WaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Etag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Etag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Etag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Etag header")
				}
			}
			// Encode "Expect-Ct" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-Ct",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCt.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-Ct header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-Dns-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Dns-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Dns-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-Xss-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Xss-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Xss-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeWaInstanceIdInstanceUploadFileApiTokenInstancePostResponse(response WaInstanceIdInstanceUploadFileApiTokenInstancePostRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *WaInstanceIdInstanceUploadFileApiTokenInstancePostOKHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
		}
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *WaInstanceIdInstanceUploadFileApiTokenInstancePostBadRequestHeaders:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		// Encoding response headers.
		{
			h := uri.NewHeaderEncoder(w.Header())
			// Encode "Access-Control-Allow-Headers" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Headers",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowHeaders.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Headers header")
				}
			}
			// Encode "Access-Control-Allow-Methods" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Methods",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowMethods.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Methods header")
				}
			}
			// Encode "Access-Control-Allow-Origin" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Access-Control-Allow-Origin",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.AccessControlAllowOrigin.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Access-Control-Allow-Origin header")
				}
			}
			// Encode "Connection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Connection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Connection.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Connection header")
				}
			}
			// Encode "Content-Length" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Length",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentLength.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Length header")
				}
			}
			// Encode "Content-Security-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Content-Security-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ContentSecurityPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Content-Security-Policy header")
				}
			}
			// Encode "Date" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Date",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Date.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Date header")
				}
			}
			// Encode "ETag" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "ETag",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ETag.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode ETag header")
				}
			}
			// Encode "Expect-CT" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Expect-CT",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ExpectCT.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Expect-CT header")
				}
			}
			// Encode "Referrer-Policy" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Referrer-Policy",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.ReferrerPolicy.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Referrer-Policy header")
				}
			}
			// Encode "Server" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Server",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Server.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Server header")
				}
			}
			// Encode "Strict-Transport-Security" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Strict-Transport-Security",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.StrictTransportSecurity.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Strict-Transport-Security header")
				}
			}
			// Encode "Vary" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "Vary",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.Vary.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode Vary header")
				}
			}
			// Encode "X-Content-Type-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Content-Type-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XContentTypeOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Content-Type-Options header")
				}
			}
			// Encode "X-DNS-Prefetch-Control" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-DNS-Prefetch-Control",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDNSPrefetchControl.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-DNS-Prefetch-Control header")
				}
			}
			// Encode "X-Download-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Download-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XDownloadOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Download-Options header")
				}
			}
			// Encode "X-Frame-Options" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Frame-Options",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XFrameOptions.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Frame-Options header")
				}
			}
			// Encode "X-Permitted-Cross-Domain-Policies" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-Permitted-Cross-Domain-Policies",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XPermittedCrossDomainPolicies.Get(); ok {
						return e.EncodeValue(conv.StringToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-Permitted-Cross-Domain-Policies header")
				}
			}
			// Encode "X-RateLimit-Remaining" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Remaining",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitRemaining.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Remaining header")
				}
			}
			// Encode "X-RateLimit-Replenish-Rate" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-RateLimit-Replenish-Rate",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XRateLimitReplenishRate.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-RateLimit-Replenish-Rate header")
				}
			}
			// Encode "X-XSS-Protection" header.
			{
				cfg := uri.HeaderParameterEncodingConfig{
					Name:    "X-XSS-Protection",
					Explode: false,
				}
				if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
					if val, ok := response.XXSSProtection.Get(); ok {
						return e.EncodeValue(conv.IntToString(val))
					}
					return nil
				}); err != nil {
					return errors.Wrap(err, "encode X-XSS-Protection header")
				}
			}
		}
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		e := new(jx.Encoder)
		response.Response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}
