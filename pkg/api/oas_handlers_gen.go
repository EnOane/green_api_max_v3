// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/http"
	"time"

	"github.com/go-faster/errors"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"
)

type codeRecorder struct {
	http.ResponseWriter
	status int
}

func (c *codeRecorder) WriteHeader(status int) {
	c.status = status
	c.ResponseWriter.WriteHeader(status)
}

func (c *codeRecorder) Unwrap() http.ResponseWriter {
	return c.ResponseWriter
}

// handleWaInstanceIdInstanceAddGroupParticipantApiTokenInstancePostRequest handles POST /waInstance{idInstance}/addGroupParticipant/{apiTokenInstance} operation.
//
// Документация [AddGroupParticipant](https://green-api.
// com/v3/docs/api/groups/AddGroupParticipant/).
//
// POST /waInstance{idInstance}/addGroupParticipant/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceAddGroupParticipantApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/addGroupParticipant/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceAddGroupParticipantApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceAddGroupParticipantApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceAddGroupParticipantApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceAddGroupParticipantApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceAddGroupParticipantApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceAddGroupParticipantApiTokenInstancePostOperation,
			OperationSummary: "Добавить участника в группу",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceAddGroupParticipantApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceAddGroupParticipantApiTokenInstancePostParams
			Response = WaInstanceIdInstanceAddGroupParticipantApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceAddGroupParticipantApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceAddGroupParticipantApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceAddGroupParticipantApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceAddGroupParticipantApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceCheckAccountApiTokenInstancePostRequest handles POST /waInstance{idInstance}/checkAccount/{apiTokenInstance} operation.
//
// Документация [CheckAccount](https://green-api.com/v3/docs/api/service/CheckAccount/).
//
// POST /waInstance{idInstance}/checkAccount/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceCheckAccountApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/checkAccount/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceCheckAccountApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceCheckAccountApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceCheckAccountApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceCheckAccountApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceCheckAccountApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceCheckAccountApiTokenInstancePostOperation,
			OperationSummary: "Проверить наличие МАХ",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceCheckAccountApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceCheckAccountApiTokenInstancePostParams
			Response = WaInstanceIdInstanceCheckAccountApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceCheckAccountApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceCheckAccountApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceCheckAccountApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceCheckAccountApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceClearMessagesQueueApiTokenInstanceGetRequest handles GET /waInstance{idInstance}/clearMessagesQueue/{apiTokenInstance} operation.
//
// Документация [ClearMessagesQueue](https://green-api.
// com/v3/docs/api/queues/ClearMessagesQueue/).
//
// GET /waInstance{idInstance}/clearMessagesQueue/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceClearMessagesQueueApiTokenInstanceGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/clearMessagesQueue/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceClearMessagesQueueApiTokenInstanceGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceClearMessagesQueueApiTokenInstanceGetOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceClearMessagesQueueApiTokenInstanceGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WaInstanceIdInstanceClearMessagesQueueApiTokenInstanceGetOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceClearMessagesQueueApiTokenInstanceGetOperation,
			OperationSummary: "Очистить очередь сообщений к отправке",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceClearMessagesQueueApiTokenInstanceGetParams
			Response = *WaInstanceIdInstanceClearMessagesQueueApiTokenInstanceGetOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceClearMessagesQueueApiTokenInstanceGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceClearMessagesQueueApiTokenInstanceGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceClearMessagesQueueApiTokenInstanceGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceClearMessagesQueueApiTokenInstanceGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceClearWebhooksQueueApiTokenInstanceDeleteRequest handles DELETE /waInstance{idInstance}/clearWebhooksQueue/{apiTokenInstance} operation.
//
// Документация [ClearWebhooksQueue](https://green-api.
// com/v3/docs/api/queues/ClearWebhooksQueue/).
//
// DELETE /waInstance{idInstance}/clearWebhooksQueue/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceClearWebhooksQueueApiTokenInstanceDeleteRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/clearWebhooksQueue/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceClearWebhooksQueueApiTokenInstanceDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceClearWebhooksQueueApiTokenInstanceDeleteOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceClearWebhooksQueueApiTokenInstanceDeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WaInstanceIdInstanceClearWebhooksQueueApiTokenInstanceDeleteOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceClearWebhooksQueueApiTokenInstanceDeleteOperation,
			OperationSummary: "Очистить очередь входящих уведомлений",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceClearWebhooksQueueApiTokenInstanceDeleteParams
			Response = *WaInstanceIdInstanceClearWebhooksQueueApiTokenInstanceDeleteOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceClearWebhooksQueueApiTokenInstanceDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceClearWebhooksQueueApiTokenInstanceDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceClearWebhooksQueueApiTokenInstanceDelete(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceClearWebhooksQueueApiTokenInstanceDeleteResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceCreateGroupApiTokenInstancePostRequest handles POST /waInstance{idInstance}/createGroup/{apiTokenInstance} operation.
//
// Документация [CreateGroup](https://green-api.com/v3/docs/api/groups/CreateGroup/).
//
// POST /waInstance{idInstance}/createGroup/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceCreateGroupApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/createGroup/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceCreateGroupApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceCreateGroupApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceCreateGroupApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceCreateGroupApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceCreateGroupApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceCreateGroupApiTokenInstancePostOperation,
			OperationSummary: "Создать группу",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceCreateGroupApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceCreateGroupApiTokenInstancePostParams
			Response = WaInstanceIdInstanceCreateGroupApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceCreateGroupApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceCreateGroupApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceCreateGroupApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceCreateGroupApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceDeleteMessageApiTokenInstancePostRequest handles POST /waInstance{idInstance}/deleteMessage/{apiTokenInstance} operation.
//
// Документация [DeleteMessage](https://green-api.com/v3/docs/api/service/DeleteMessage).
//
// POST /waInstance{idInstance}/deleteMessage/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceDeleteMessageApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/deleteMessage/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceDeleteMessageApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceDeleteMessageApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceDeleteMessageApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceDeleteMessageApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceDeleteMessageApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceDeleteMessageApiTokenInstancePostOperation,
			OperationSummary: "Удалить сообщение",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = *WaInstanceIdInstanceDeleteMessageApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceDeleteMessageApiTokenInstancePostParams
			Response = WaInstanceIdInstanceDeleteMessageApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceDeleteMessageApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceDeleteMessageApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceDeleteMessageApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceDeleteMessageApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceDeleteNotificationApiTokenInstanceReceiptIdDeleteRequest handles DELETE /waInstance{idInstance}/deleteNotification/{apiTokenInstance}/{receiptId} operation.
//
// Документация [DeleteNotification](https://green-api.
// com/v3/docs/api/receiving/technology-http-api/DeleteNotification/).
//
// DELETE /waInstance{idInstance}/deleteNotification/{apiTokenInstance}/{receiptId}
func (s *Server) handleWaInstanceIdInstanceDeleteNotificationApiTokenInstanceReceiptIdDeleteRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/deleteNotification/{apiTokenInstance}/{receiptId}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceDeleteNotificationApiTokenInstanceReceiptIdDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceDeleteNotificationApiTokenInstanceReceiptIdDeleteOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceDeleteNotificationApiTokenInstanceReceiptIdDeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WaInstanceIdInstanceDeleteNotificationApiTokenInstanceReceiptIdDeleteOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceDeleteNotificationApiTokenInstanceReceiptIdDeleteOperation,
			OperationSummary: "Удалить уведомление",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
				{
					Name: "receiptId",
					In:   "path",
				}: params.ReceiptId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceDeleteNotificationApiTokenInstanceReceiptIdDeleteParams
			Response = *WaInstanceIdInstanceDeleteNotificationApiTokenInstanceReceiptIdDeleteOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceDeleteNotificationApiTokenInstanceReceiptIdDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceDeleteNotificationApiTokenInstanceReceiptIdDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceDeleteNotificationApiTokenInstanceReceiptIdDelete(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceDeleteNotificationApiTokenInstanceReceiptIdDeleteResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceDownloadFileApiTokenInstancePostRequest handles POST /waInstance{idInstance}/downloadFile/{apiTokenInstance} operation.
//
// Документация [DownloadFile](https://green-api.
// com/v3/docs/api/receiving/files/DownloadFile/).
//
// POST /waInstance{idInstance}/downloadFile/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceDownloadFileApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/downloadFile/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceDownloadFileApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceDownloadFileApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceDownloadFileApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceDownloadFileApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceDownloadFileApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceDownloadFileApiTokenInstancePostOperation,
			OperationSummary: "Скачать файл из входящего сообщения",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceDownloadFileApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceDownloadFileApiTokenInstancePostParams
			Response = WaInstanceIdInstanceDownloadFileApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceDownloadFileApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceDownloadFileApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceDownloadFileApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceDownloadFileApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceEditMessageApiTokenInstancePostRequest handles POST /waInstance{idInstance}/editMessage/{apiTokenInstance} operation.
//
// Документация [EditMessage](https://green-api.com/v3/docs/api/service/EditMessage).
//
// POST /waInstance{idInstance}/editMessage/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceEditMessageApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/editMessage/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceEditMessageApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceEditMessageApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceEditMessageApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceEditMessageApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceEditMessageApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceEditMessageApiTokenInstancePostOperation,
			OperationSummary: "Редактировать сообщение",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceEditMessageApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceEditMessageApiTokenInstancePostParams
			Response = WaInstanceIdInstanceEditMessageApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceEditMessageApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceEditMessageApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceEditMessageApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceEditMessageApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceGetAccountSettingsApiTokenInstanceGetRequest handles GET /waInstance{idInstance}/getAccountSettings/{apiTokenInstance} operation.
//
// Документация [GetAccountSettings](https://green-api.
// com/v3/docs/api/account/GetAccountSettings/).
//
// GET /waInstance{idInstance}/getAccountSettings/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceGetAccountSettingsApiTokenInstanceGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/getAccountSettings/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceGetAccountSettingsApiTokenInstanceGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceGetAccountSettingsApiTokenInstanceGetOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceGetAccountSettingsApiTokenInstanceGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceGetAccountSettingsApiTokenInstanceGetRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *WaInstanceIdInstanceGetAccountSettingsApiTokenInstanceGetOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceGetAccountSettingsApiTokenInstanceGetOperation,
			OperationSummary: "Получить информацию об аккаунте",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = *WaInstanceIdInstanceGetAccountSettingsApiTokenInstanceGetReq
			Params   = WaInstanceIdInstanceGetAccountSettingsApiTokenInstanceGetParams
			Response = *WaInstanceIdInstanceGetAccountSettingsApiTokenInstanceGetOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceGetAccountSettingsApiTokenInstanceGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceGetAccountSettingsApiTokenInstanceGet(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceGetAccountSettingsApiTokenInstanceGet(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceGetAccountSettingsApiTokenInstanceGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceGetAvatarApiTokenInstancePostRequest handles POST /waInstance{idInstance}/getAvatar/{apiTokenInstance} operation.
//
// Документация [GetAvatar](https://green-api.com/v3/docs/api/service/GetAvatar).
//
// POST /waInstance{idInstance}/getAvatar/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceGetAvatarApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/getAvatar/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceGetAvatarApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceGetAvatarApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceGetAvatarApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceGetAvatarApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceGetAvatarApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceGetAvatarApiTokenInstancePostOperation,
			OperationSummary: "Получить аватар контакта",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceGetAvatarApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceGetAvatarApiTokenInstancePostParams
			Response = WaInstanceIdInstanceGetAvatarApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceGetAvatarApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceGetAvatarApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceGetAvatarApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceGetAvatarApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceGetChatHistoryApiTokenInstancePostRequest handles POST /waInstance{idInstance}/getChatHistory/{apiTokenInstance} operation.
//
// Документация [GetChatHistory](https://green-api.
// com/v3/docs/api/journals/GetChatHistory/).
//
// POST /waInstance{idInstance}/getChatHistory/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceGetChatHistoryApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/getChatHistory/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceGetChatHistoryApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceGetChatHistoryApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceGetChatHistoryApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceGetChatHistoryApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceGetChatHistoryApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceGetChatHistoryApiTokenInstancePostOperation,
			OperationSummary: "Получить историю сообщений чата",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceGetChatHistoryApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceGetChatHistoryApiTokenInstancePostParams
			Response = WaInstanceIdInstanceGetChatHistoryApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceGetChatHistoryApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceGetChatHistoryApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceGetChatHistoryApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceGetChatHistoryApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceGetChatsApiTokenInstanceGetRequest handles GET /waInstance{idInstance}/GetChats/{apiTokenInstance} operation.
//
// Документация [GetChats](https://green-api.com/v3/docs/api/service/GetChats/).
//
// GET /waInstance{idInstance}/GetChats/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceGetChatsApiTokenInstanceGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/GetChats/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceGetChatsApiTokenInstanceGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceGetChatsApiTokenInstanceGetOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceGetChatsApiTokenInstanceGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WaInstanceIdInstanceGetChatsApiTokenInstanceGetOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceGetChatsApiTokenInstanceGetOperation,
			OperationSummary: "Получить список чатов",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceGetChatsApiTokenInstanceGetParams
			Response = *WaInstanceIdInstanceGetChatsApiTokenInstanceGetOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceGetChatsApiTokenInstanceGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceGetChatsApiTokenInstanceGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceGetChatsApiTokenInstanceGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceGetChatsApiTokenInstanceGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceGetContactInfoApiTokenInstancePostRequest handles POST /waInstance{idInstance}/GetContactInfo/{apiTokenInstance} operation.
//
// Документация [GetContactInfo](https://green-api.
// com/v3/docs/api/service/GetContactInfo/).
//
// POST /waInstance{idInstance}/GetContactInfo/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceGetContactInfoApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/GetContactInfo/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceGetContactInfoApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceGetContactInfoApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceGetContactInfoApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceGetContactInfoApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceGetContactInfoApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceGetContactInfoApiTokenInstancePostOperation,
			OperationSummary: "Получить инфо контакта",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceGetContactInfoApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceGetContactInfoApiTokenInstancePostParams
			Response = WaInstanceIdInstanceGetContactInfoApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceGetContactInfoApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceGetContactInfoApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceGetContactInfoApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceGetContactInfoApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceGetContactsApiTokenInstanceGetRequest handles GET /waInstance{idInstance}/getContacts/{apiTokenInstance} operation.
//
// Документация [GetContacts](https://green-api.com/v3/docs/api/service/GetContacts/).
//
// GET /waInstance{idInstance}/getContacts/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceGetContactsApiTokenInstanceGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/getContacts/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceGetContactsApiTokenInstanceGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceGetContactsApiTokenInstanceGetOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceGetContactsApiTokenInstanceGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WaInstanceIdInstanceGetContactsApiTokenInstanceGetOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceGetContactsApiTokenInstanceGetOperation,
			OperationSummary: "Получить контакты",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceGetContactsApiTokenInstanceGetParams
			Response = *WaInstanceIdInstanceGetContactsApiTokenInstanceGetOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceGetContactsApiTokenInstanceGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceGetContactsApiTokenInstanceGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceGetContactsApiTokenInstanceGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceGetContactsApiTokenInstanceGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceGetGroupDataApiTokenInstancePostRequest handles POST /waInstance{idInstance}/getGroupData/{apiTokenInstance} operation.
//
// Документация [GetGroupData](https://green-api.com/v3/docs/api/groups/GetGroupData/).
//
// POST /waInstance{idInstance}/getGroupData/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceGetGroupDataApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/getGroupData/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceGetGroupDataApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceGetGroupDataApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceGetGroupDataApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceGetGroupDataApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceGetGroupDataApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceGetGroupDataApiTokenInstancePostOperation,
			OperationSummary: "Получить информацию о группе",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceGetGroupDataApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceGetGroupDataApiTokenInstancePostParams
			Response = WaInstanceIdInstanceGetGroupDataApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceGetGroupDataApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceGetGroupDataApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceGetGroupDataApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceGetGroupDataApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceGetMessageApiTokenInstancePostRequest handles POST /waInstance{idInstance}/getMessage/{apiTokenInstance} operation.
//
// Документация [GetMessage](https://green-api.com/v3/docs/api/journals/GetMessage/).
//
// POST /waInstance{idInstance}/getMessage/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceGetMessageApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/getMessage/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceGetMessageApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceGetMessageApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceGetMessageApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceGetMessageApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceGetMessageApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceGetMessageApiTokenInstancePostOperation,
			OperationSummary: "Получить сообщение чата",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceGetMessageApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceGetMessageApiTokenInstancePostParams
			Response = WaInstanceIdInstanceGetMessageApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceGetMessageApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceGetMessageApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceGetMessageApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceGetMessageApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceGetMessagesCountApiTokenInstanceGetRequest handles GET /waInstance{idInstance}/getMessagesCount/{apiTokenInstance} operation.
//
// Документация [GetMessagesCount](https://green-api.
// com/v3/docs/api/queues/GetMessagesCount).
//
// GET /waInstance{idInstance}/getMessagesCount/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceGetMessagesCountApiTokenInstanceGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/getMessagesCount/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceGetMessagesCountApiTokenInstanceGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceGetMessagesCountApiTokenInstanceGetOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceGetMessagesCountApiTokenInstanceGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WaInstanceIdInstanceGetMessagesCountApiTokenInstanceGetOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceGetMessagesCountApiTokenInstanceGetOperation,
			OperationSummary: "Получить количество сообщений к отправке",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceGetMessagesCountApiTokenInstanceGetParams
			Response = *WaInstanceIdInstanceGetMessagesCountApiTokenInstanceGetOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceGetMessagesCountApiTokenInstanceGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceGetMessagesCountApiTokenInstanceGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceGetMessagesCountApiTokenInstanceGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceGetMessagesCountApiTokenInstanceGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceGetSettingsApiTokenInstanceGetRequest handles GET /waInstance{idInstance}/getSettings/{apiTokenInstance} operation.
//
// Документация [GetSettings](https://green-api.com/v3/docs/api/account/GetSettings/).
//
// GET /waInstance{idInstance}/getSettings/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceGetSettingsApiTokenInstanceGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/getSettings/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceGetSettingsApiTokenInstanceGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceGetSettingsApiTokenInstanceGetOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceGetSettingsApiTokenInstanceGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WaInstanceIdInstanceGetSettingsApiTokenInstanceGetOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceGetSettingsApiTokenInstanceGetOperation,
			OperationSummary: "Получить настройки инстанса",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceGetSettingsApiTokenInstanceGetParams
			Response = *WaInstanceIdInstanceGetSettingsApiTokenInstanceGetOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceGetSettingsApiTokenInstanceGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceGetSettingsApiTokenInstanceGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceGetSettingsApiTokenInstanceGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceGetSettingsApiTokenInstanceGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceGetStateInstanceApiTokenInstanceGetRequest handles GET /waInstance{idInstance}/getStateInstance/{apiTokenInstance} operation.
//
// Документация [GetStateInstance](https://green-api.
// com/v3/docs/api/account/GetStateInstance/).
//
// GET /waInstance{idInstance}/getStateInstance/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceGetStateInstanceApiTokenInstanceGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/getStateInstance/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceGetStateInstanceApiTokenInstanceGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceGetStateInstanceApiTokenInstanceGetOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceGetStateInstanceApiTokenInstanceGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WaInstanceIdInstanceGetStateInstanceApiTokenInstanceGetOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceGetStateInstanceApiTokenInstanceGetOperation,
			OperationSummary: "Получить состояние инстанса",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceGetStateInstanceApiTokenInstanceGetParams
			Response = *WaInstanceIdInstanceGetStateInstanceApiTokenInstanceGetOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceGetStateInstanceApiTokenInstanceGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceGetStateInstanceApiTokenInstanceGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceGetStateInstanceApiTokenInstanceGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceGetStateInstanceApiTokenInstanceGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceGetWebhooksCountApiTokenInstanceGetRequest handles GET /waInstance{idInstance}/getWebhooksCount/{apiTokenInstance} operation.
//
// Документация [GetWebhooksCount](https://green-api.
// com/v3/docs/api/queues/GetWebhooksCount/).
//
// GET /waInstance{idInstance}/getWebhooksCount/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceGetWebhooksCountApiTokenInstanceGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/getWebhooksCount/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceGetWebhooksCountApiTokenInstanceGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceGetWebhooksCountApiTokenInstanceGetOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceGetWebhooksCountApiTokenInstanceGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WaInstanceIdInstanceGetWebhooksCountApiTokenInstanceGetOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceGetWebhooksCountApiTokenInstanceGetOperation,
			OperationSummary: "Получить количество уведомлений во входящей очереди",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceGetWebhooksCountApiTokenInstanceGetParams
			Response = *WaInstanceIdInstanceGetWebhooksCountApiTokenInstanceGetOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceGetWebhooksCountApiTokenInstanceGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceGetWebhooksCountApiTokenInstanceGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceGetWebhooksCountApiTokenInstanceGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceGetWebhooksCountApiTokenInstanceGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceLastIncomingMessagesApiTokenInstanceGetRequest handles GET /waInstance{idInstance}/lastIncomingMessages/{apiTokenInstance} operation.
//
// Документация [LastIncomingMessages](https://green-api.
// com/v3/docs/api/journals/LastIncomingMessages/).
//
// GET /waInstance{idInstance}/lastIncomingMessages/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceLastIncomingMessagesApiTokenInstanceGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/lastIncomingMessages/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceLastIncomingMessagesApiTokenInstanceGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceLastIncomingMessagesApiTokenInstanceGetOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceLastIncomingMessagesApiTokenInstanceGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WaInstanceIdInstanceLastIncomingMessagesApiTokenInstanceGetOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceLastIncomingMessagesApiTokenInstanceGetOperation,
			OperationSummary: "Получить журнал входящих сообщений",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "minutes",
					In:   "query",
				}: params.Minutes,
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceLastIncomingMessagesApiTokenInstanceGetParams
			Response = *WaInstanceIdInstanceLastIncomingMessagesApiTokenInstanceGetOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceLastIncomingMessagesApiTokenInstanceGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceLastIncomingMessagesApiTokenInstanceGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceLastIncomingMessagesApiTokenInstanceGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceLastIncomingMessagesApiTokenInstanceGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceLastOutgoingMessagesApiTokenInstanceGetRequest handles GET /waInstance{idInstance}/lastOutgoingMessages/{apiTokenInstance} operation.
//
// Документация [LastOutgoingMessages](https://green-api.
// com/v3/docs/api/journals/LastOutgoingMessages/).
//
// GET /waInstance{idInstance}/lastOutgoingMessages/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceLastOutgoingMessagesApiTokenInstanceGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/lastOutgoingMessages/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceLastOutgoingMessagesApiTokenInstanceGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceLastOutgoingMessagesApiTokenInstanceGetOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceLastOutgoingMessagesApiTokenInstanceGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WaInstanceIdInstanceLastOutgoingMessagesApiTokenInstanceGetOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceLastOutgoingMessagesApiTokenInstanceGetOperation,
			OperationSummary: "Получить журнал отправленных сообщений",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "minutes",
					In:   "query",
				}: params.Minutes,
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceLastOutgoingMessagesApiTokenInstanceGetParams
			Response = *WaInstanceIdInstanceLastOutgoingMessagesApiTokenInstanceGetOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceLastOutgoingMessagesApiTokenInstanceGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceLastOutgoingMessagesApiTokenInstanceGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceLastOutgoingMessagesApiTokenInstanceGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceLastOutgoingMessagesApiTokenInstanceGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceLeaveGroupApiTokenInstancePostRequest handles POST /waInstance{idInstance}/leaveGroup/{apiTokenInstance} operation.
//
// Документация [LeaveGroup](https://green-api.com/v3/docs/api/groups/LeaveGroup/).
//
// POST /waInstance{idInstance}/leaveGroup/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceLeaveGroupApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/leaveGroup/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceLeaveGroupApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceLeaveGroupApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceLeaveGroupApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceLeaveGroupApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceLeaveGroupApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceLeaveGroupApiTokenInstancePostOperation,
			OperationSummary: "Выйти из группы",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceLeaveGroupApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceLeaveGroupApiTokenInstancePostParams
			Response = WaInstanceIdInstanceLeaveGroupApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceLeaveGroupApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceLeaveGroupApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceLeaveGroupApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceLeaveGroupApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceLogoutApiTokenInstanceGetRequest handles GET /waInstance{idInstance}/logout/{apiTokenInstance} operation.
//
// Документация [Logout](https://green-api.com/v3/docs/api/account/Logout/).
//
// GET /waInstance{idInstance}/logout/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceLogoutApiTokenInstanceGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/logout/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceLogoutApiTokenInstanceGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceLogoutApiTokenInstanceGetOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceLogoutApiTokenInstanceGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WaInstanceIdInstanceLogoutApiTokenInstanceGetOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceLogoutApiTokenInstanceGetOperation,
			OperationSummary: "Разлогинить инстанс",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceLogoutApiTokenInstanceGetParams
			Response = *WaInstanceIdInstanceLogoutApiTokenInstanceGetOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceLogoutApiTokenInstanceGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceLogoutApiTokenInstanceGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceLogoutApiTokenInstanceGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceLogoutApiTokenInstanceGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceQrApiTokenInstanceGetRequest handles GET /waInstance{idInstance}/qr/{apiTokenInstance} operation.
//
// Документация [QR](https://green-api.com/v3/docs/api/account/QR/).
//
// GET /waInstance{idInstance}/qr/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceQrApiTokenInstanceGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/qr/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceQrApiTokenInstanceGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceQrApiTokenInstanceGetOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceQrApiTokenInstanceGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WaInstanceIdInstanceQrApiTokenInstanceGetDefStatusCode
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceQrApiTokenInstanceGetOperation,
			OperationSummary: "Получить QR-код",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceQrApiTokenInstanceGetParams
			Response = *WaInstanceIdInstanceQrApiTokenInstanceGetDefStatusCode
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceQrApiTokenInstanceGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceQrApiTokenInstanceGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceQrApiTokenInstanceGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceQrApiTokenInstanceGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceReadChatApiTokenInstancePostRequest handles POST /waInstance{idInstance}/readChat/{apiTokenInstance} operation.
//
// Документация [ReadChat](https://green-api.com/v3/docs/api/marks/ReadChat/).
//
// POST /waInstance{idInstance}/readChat/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceReadChatApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/readChat/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceReadChatApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceReadChatApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceReadChatApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceReadChatApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceReadChatApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceReadChatApiTokenInstancePostOperation,
			OperationSummary: "Отметить сообщение в чате прочитанным",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "User-Agent",
					In:   "header",
				}: params.UserAgent,
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceReadChatApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceReadChatApiTokenInstancePostParams
			Response = WaInstanceIdInstanceReadChatApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceReadChatApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceReadChatApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceReadChatApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceReadChatApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceRebootApiTokenInstanceGetRequest handles GET /waInstance{idInstance}/reboot/{apiTokenInstance} operation.
//
// Документация [Reboot](https://green-api.com/v3/docs/api/account/Reboot/).
//
// GET /waInstance{idInstance}/reboot/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceRebootApiTokenInstanceGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/reboot/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceRebootApiTokenInstanceGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceRebootApiTokenInstanceGetOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceRebootApiTokenInstanceGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WaInstanceIdInstanceRebootApiTokenInstanceGetOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceRebootApiTokenInstanceGetOperation,
			OperationSummary: "Перезапустить инстанс",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceRebootApiTokenInstanceGetParams
			Response = *WaInstanceIdInstanceRebootApiTokenInstanceGetOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceRebootApiTokenInstanceGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceRebootApiTokenInstanceGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceRebootApiTokenInstanceGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceRebootApiTokenInstanceGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceReceiveNotificationApiTokenInstanceGetRequest handles GET /waInstance{idInstance}/receiveNotification/{apiTokenInstance} operation.
//
// Документация [ReceiveNotification](https://green-api.
// com/v3/docs/api/receiving/technology-http-api/ReceiveNotification/).
//
// GET /waInstance{idInstance}/receiveNotification/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceReceiveNotificationApiTokenInstanceGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/receiveNotification/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceReceiveNotificationApiTokenInstanceGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceReceiveNotificationApiTokenInstanceGetOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceReceiveNotificationApiTokenInstanceGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WaInstanceIdInstanceReceiveNotificationApiTokenInstanceGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceReceiveNotificationApiTokenInstanceGetOperation,
			OperationSummary: "Получить уведомление",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "receiveTimeout",
					In:   "query",
				}: params.ReceiveTimeout,
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceReceiveNotificationApiTokenInstanceGetParams
			Response = *WaInstanceIdInstanceReceiveNotificationApiTokenInstanceGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceReceiveNotificationApiTokenInstanceGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceReceiveNotificationApiTokenInstanceGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceReceiveNotificationApiTokenInstanceGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceReceiveNotificationApiTokenInstanceGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceRemoveAdminApiTokenInstancePostRequest handles POST /waInstance{idInstance}/removeAdmin/{apiTokenInstance} operation.
//
// Документация [RemoveAdmin](https://green-api.com/v3/docs/api/groups/RemoveAdmin/).
//
// POST /waInstance{idInstance}/removeAdmin/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceRemoveAdminApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/removeAdmin/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceRemoveAdminApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceRemoveAdminApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceRemoveAdminApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceRemoveAdminApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceRemoveAdminApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceRemoveAdminApiTokenInstancePostOperation,
			OperationSummary: "Отозвать права администратора группы",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceRemoveAdminApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceRemoveAdminApiTokenInstancePostParams
			Response = WaInstanceIdInstanceRemoveAdminApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceRemoveAdminApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceRemoveAdminApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceRemoveAdminApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceRemoveAdminApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePostRequest handles POST /waInstance{idInstance}/removeGroupParticipant/{apiTokenInstance} operation.
//
// Документация [RemoveGroupParticipant](https://green-api.
// com/v3/docs/api/groups/RemoveGroupParticipant/).
//
// POST /waInstance{idInstance}/removeGroupParticipant/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/removeGroupParticipant/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePostOperation,
			OperationSummary: "Удалить участника из группы",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePostParams
			Response = WaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceRemoveGroupParticipantApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceSendContactApiTokenInstancePostRequest handles POST /waInstance{idInstance}/sendContact/{apiTokenInstance} operation.
//
// Документация [SendContact](https://green-api.com/v3/docs/api/sending/SendContact/).
//
// POST /waInstance{idInstance}/sendContact/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceSendContactApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/sendContact/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceSendContactApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceSendContactApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceSendContactApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceSendContactApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceSendContactApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceSendContactApiTokenInstancePostOperation,
			OperationSummary: "Отправить контакт",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "User-Agent",
					In:   "header",
				}: params.UserAgent,
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceSendContactApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceSendContactApiTokenInstancePostParams
			Response = WaInstanceIdInstanceSendContactApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceSendContactApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceSendContactApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceSendContactApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceSendContactApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceSendFileByUploadApiTokenInstancePostRequest handles POST /waInstance{idInstance}/sendFileByUpload/{apiTokenInstance} operation.
//
// Документация [SendFileByUpload](https://green-api.
// com/v3/docs/api/sending/SendFileByUpload).
//
// POST /waInstance{idInstance}/sendFileByUpload/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceSendFileByUploadApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/sendFileByUpload/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceSendFileByUploadApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceSendFileByUploadApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceSendFileByUploadApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response WaInstanceIdInstanceSendFileByUploadApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceSendFileByUploadApiTokenInstancePostOperation,
			OperationSummary: "Отправить видео, аудио, изображение, документ",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "User-Agent",
					In:   "header",
				}: params.UserAgent,
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceSendFileByUploadApiTokenInstancePostParams
			Response = WaInstanceIdInstanceSendFileByUploadApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceSendFileByUploadApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceSendFileByUploadApiTokenInstancePost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceSendFileByUploadApiTokenInstancePost(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceSendFileByUploadApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceSendFileByUrlApiTokenInstancePostRequest handles POST /waInstance{idInstance}/sendFileByUrl/{apiTokenInstance} operation.
//
// Документация [SendFileByUrl](https://green-api.com/v3/docs/api/sending/SendFileByUrl).
//
// POST /waInstance{idInstance}/sendFileByUrl/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceSendFileByUrlApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/sendFileByUrl/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceSendFileByUrlApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceSendFileByUrlApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceSendFileByUrlApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceSendFileByUrlApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceSendFileByUrlApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceSendFileByUrlApiTokenInstancePostOperation,
			OperationSummary: "Отправить видео, аудио, изображение, документ по URL",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "User-Agent",
					In:   "header",
				}: params.UserAgent,
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceSendFileByUrlApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceSendFileByUrlApiTokenInstancePostParams
			Response = WaInstanceIdInstanceSendFileByUrlApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceSendFileByUrlApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceSendFileByUrlApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceSendFileByUrlApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceSendFileByUrlApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceSendLocationApiTokenInstancePostRequest handles POST /waInstance{idInstance}/sendLocation/{apiTokenInstance} operation.
//
// Документация [SendLocation](https://green-api.com/v3/docs/api/sending/SendLocation/).
//
// POST /waInstance{idInstance}/sendLocation/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceSendLocationApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/sendLocation/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceSendLocationApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceSendLocationApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceSendLocationApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceSendLocationApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceSendLocationApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceSendLocationApiTokenInstancePostOperation,
			OperationSummary: "Отправить геолокацию",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "User-Agent",
					In:   "header",
				}: params.UserAgent,
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceSendLocationApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceSendLocationApiTokenInstancePostParams
			Response = WaInstanceIdInstanceSendLocationApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceSendLocationApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceSendLocationApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceSendLocationApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceSendLocationApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceSendMessageApiTokenInstancePostRequest handles POST /waInstance{idInstance}/sendMessage/{apiTokenInstance} operation.
//
// Документация [SendMessage](https://green-api.com/v3/docs/api/sending/SendMessage/).
//
// POST /waInstance{idInstance}/sendMessage/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceSendMessageApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/sendMessage/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceSendMessageApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceSendMessageApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceSendMessageApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceSendMessageApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceSendMessageApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceSendMessageApiTokenInstancePostOperation,
			OperationSummary: "Отправить текст",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "User-Agent",
					In:   "header",
				}: params.UserAgent,
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceSendMessageApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceSendMessageApiTokenInstancePostParams
			Response = WaInstanceIdInstanceSendMessageApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceSendMessageApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceSendMessageApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceSendMessageApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceSendMessageApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceSendTypingApiTokenInstancePostRequest handles POST /waInstance{idInstance}/sendTyping/{apiTokenInstance} operation.
//
// Документация [SendTyping](https://green-api.com/v3/docs/api/service/SendTyping/).
//
// POST /waInstance{idInstance}/sendTyping/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceSendTypingApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/sendTyping/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceSendTypingApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceSendTypingApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceSendTypingApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceSendTypingApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceSendTypingApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceSendTypingApiTokenInstancePostOperation,
			OperationSummary: "Отправить уведомление набора",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "User-Agent",
					In:   "header",
				}: params.UserAgent,
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = *WaInstanceIdInstanceSendTypingApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceSendTypingApiTokenInstancePostParams
			Response = WaInstanceIdInstanceSendTypingApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceSendTypingApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceSendTypingApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceSendTypingApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceSendTypingApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceSetGroupAdminApiTokenInstancePostRequest handles POST /waInstance{idInstance}/setGroupAdmin/{apiTokenInstance} operation.
//
// Документация [SetGroupAdmin](https://green-api.com/v3/docs/api/groups/SetGroupAdmin/).
//
// POST /waInstance{idInstance}/setGroupAdmin/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceSetGroupAdminApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/setGroupAdmin/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceSetGroupAdminApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceSetGroupAdminApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceSetGroupAdminApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceSetGroupAdminApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceSetGroupAdminApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceSetGroupAdminApiTokenInstancePostOperation,
			OperationSummary: "Назначить права администратора группы",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceSetGroupAdminApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceSetGroupAdminApiTokenInstancePostParams
			Response = WaInstanceIdInstanceSetGroupAdminApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceSetGroupAdminApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceSetGroupAdminApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceSetGroupAdminApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceSetGroupAdminApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceSetGroupPictureApiTokenInstancePostRequest handles POST /waInstance{idInstance}/setGroupPicture/{apiTokenInstance} operation.
//
// Документация [SetGroupPicture](https://green-api.
// com/v3/docs/api/groups/SetGroupPicture/).
//
// POST /waInstance{idInstance}/setGroupPicture/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceSetGroupPictureApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/setGroupPicture/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceSetGroupPictureApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceSetGroupPictureApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceSetGroupPictureApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response WaInstanceIdInstanceSetGroupPictureApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceSetGroupPictureApiTokenInstancePostOperation,
			OperationSummary: "Установить фото группы",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceSetGroupPictureApiTokenInstancePostParams
			Response = WaInstanceIdInstanceSetGroupPictureApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceSetGroupPictureApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceSetGroupPictureApiTokenInstancePost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceSetGroupPictureApiTokenInstancePost(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceSetGroupPictureApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceSetProfilePictureApiTokenInstancePostRequest handles POST /waInstance{idInstance}/setProfilePicture/{apiTokenInstance} operation.
//
// Документация [SetProfilePicture](https://green-api.
// com/v3/docs/api/account/SetProfilePicture/).
//
// POST /waInstance{idInstance}/setProfilePicture/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceSetProfilePictureApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/setProfilePicture/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceSetProfilePictureApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceSetProfilePictureApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceSetProfilePictureApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response WaInstanceIdInstanceSetProfilePictureApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceSetProfilePictureApiTokenInstancePostOperation,
			OperationSummary: "Установить фото профиля",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceSetProfilePictureApiTokenInstancePostParams
			Response = WaInstanceIdInstanceSetProfilePictureApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceSetProfilePictureApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceSetProfilePictureApiTokenInstancePost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceSetProfilePictureApiTokenInstancePost(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceSetProfilePictureApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceSetSettingsApiTokenInstancePostRequest handles POST /waInstance{idInstance}/setSettings/{apiTokenInstance} operation.
//
// Документация [SetSettings](https://green-api.com/v3/docs/api/account/SetSettings/).
//
// POST /waInstance{idInstance}/setSettings/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceSetSettingsApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/setSettings/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceSetSettingsApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceSetSettingsApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceSetSettingsApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceSetSettingsApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *WaInstanceIdInstanceSetSettingsApiTokenInstancePostOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceSetSettingsApiTokenInstancePostOperation,
			OperationSummary: "Установить настройки инстанса",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceSetSettingsApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceSetSettingsApiTokenInstancePostParams
			Response = *WaInstanceIdInstanceSetSettingsApiTokenInstancePostOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceSetSettingsApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceSetSettingsApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceSetSettingsApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceSetSettingsApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceShowMessagesQueueApiTokenInstanceGetRequest handles GET /waInstance{idInstance}/showMessagesQueue/{apiTokenInstance} operation.
//
// Документация [ShowMessagesQueue](https://green-api.
// com/v3/docs/api/queues/ShowMessagesQueue/).
//
// GET /waInstance{idInstance}/showMessagesQueue/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceShowMessagesQueueApiTokenInstanceGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/showMessagesQueue/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceShowMessagesQueueApiTokenInstanceGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceShowMessagesQueueApiTokenInstanceGetOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceShowMessagesQueueApiTokenInstanceGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WaInstanceIdInstanceShowMessagesQueueApiTokenInstanceGetOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceShowMessagesQueueApiTokenInstanceGetOperation,
			OperationSummary: "Получить очередь сообщений к отправке",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceShowMessagesQueueApiTokenInstanceGetParams
			Response = *WaInstanceIdInstanceShowMessagesQueueApiTokenInstanceGetOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceShowMessagesQueueApiTokenInstanceGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceShowMessagesQueueApiTokenInstanceGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceShowMessagesQueueApiTokenInstanceGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceShowMessagesQueueApiTokenInstanceGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceUpdateGroupNameApiTokenInstancePostRequest handles POST /waInstance{idInstance}/updateGroupName/{apiTokenInstance} operation.
//
// Документация [UpdateGroupName](https://green-api.
// com/v3/docs/api/groups/UpdateGroupName/).
//
// POST /waInstance{idInstance}/updateGroupName/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceUpdateGroupNameApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/updateGroupName/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceUpdateGroupNameApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceUpdateGroupNameApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceUpdateGroupNameApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceUpdateGroupNameApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceUpdateGroupNameApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceUpdateGroupNameApiTokenInstancePostOperation,
			OperationSummary: "Изменить имя группы",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceUpdateGroupNameApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceUpdateGroupNameApiTokenInstancePostParams
			Response = WaInstanceIdInstanceUpdateGroupNameApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceUpdateGroupNameApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceUpdateGroupNameApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceUpdateGroupNameApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceUpdateGroupNameApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePostRequest handles POST /waInstance{idInstance}/updateGroupSettings/{apiTokenInstance} operation.
//
// Документация [UpdateGroupSettings](https://green-api.
// com/v3/docs/api/groups/UpdateGroupSettings/).
//
// POST /waInstance{idInstance}/updateGroupSettings/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/updateGroupSettings/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeWaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response WaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePostOperation,
			OperationSummary: "Обновить настройки группы",
			OperationID:      "",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = OptWaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePostReq
			Params   = WaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePostParams
			Response = WaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceUpdateGroupSettingsApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWaInstanceIdInstanceUploadFileApiTokenInstancePostRequest handles POST /waInstance{idInstance}/uploadFile/{apiTokenInstance} operation.
//
// Документация [UploadFile](https://green-api.com/v3/docs/api/sending/UploadFile).
//
// POST /waInstance{idInstance}/uploadFile/{apiTokenInstance}
func (s *Server) handleWaInstanceIdInstanceUploadFileApiTokenInstancePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/waInstance{idInstance}/uploadFile/{apiTokenInstance}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), WaInstanceIdInstanceUploadFileApiTokenInstancePostOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: WaInstanceIdInstanceUploadFileApiTokenInstancePostOperation,
			ID:   "",
		}
	)
	params, err := decodeWaInstanceIdInstanceUploadFileApiTokenInstancePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response WaInstanceIdInstanceUploadFileApiTokenInstancePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    WaInstanceIdInstanceUploadFileApiTokenInstancePostOperation,
			OperationSummary: "Выгрузить файл",
			OperationID:      "",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "User-Agent",
					In:   "header",
				}: params.UserAgent,
				{
					Name: "idInstance",
					In:   "path",
				}: params.IdInstance,
				{
					Name: "apiTokenInstance",
					In:   "path",
				}: params.ApiTokenInstance,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = WaInstanceIdInstanceUploadFileApiTokenInstancePostParams
			Response = WaInstanceIdInstanceUploadFileApiTokenInstancePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackWaInstanceIdInstanceUploadFileApiTokenInstancePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WaInstanceIdInstanceUploadFileApiTokenInstancePost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.WaInstanceIdInstanceUploadFileApiTokenInstancePost(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWaInstanceIdInstanceUploadFileApiTokenInstancePostResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}
